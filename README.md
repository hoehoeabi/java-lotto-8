# java-lotto-precourse
------------------------------------------------
제 코드를 리뷰하러 와주셔서 진심으로 감사합니다. 저도 프리코스에 참여하며 다른 분들의 코드를 통해 많이 배우고 있습니다.
보내주시는 소중한 피드백을 꼼꼼히 확인하고 더 성장하는 기회로 삼겠습니다. 잘 부탁드립니다!"
------------------------------------------------
# 구현 목록
1. 구입금액을 입력 받습니다.
2. 로또 구매 개수를 구한뒤 해당 개수만큼 로또 번호를 무작위로 뽑아줍니다.
3. 당첨번호를 입력받습니다.
4. 보너스 번호를 입력받습니다.
5. 당첨통계를 보여줍니다.
6. 수익률을 보여줍니다.

------------------------------------------------
# 예외 목록
- 구입금액은 1000원 단위여야합니다.
- 구입 금액과 보너스 숫자는 숫자로 파싱이 되어야합니다.
- 구입 금액과 보너스 숫자는 0이면 안됩니다.
- 로또 당첨 번호는 중복될 수 없습니다.
- 로또 당첨번호는 6개의 숫자와 5개의 `,`이여야 하며 ^(\d+,){5}\d+$의 형태여야합니다.
- 보너스 숫자는 로또 당첨 번호와 같을 수 없습니다.
------------------------------------------------
# 패키지 구조 
```
├── main
│   └── java
│       └── lotto
│           ├── Application.java
│           ├── config
│           │   ├── AppConfig.java
│           │   └── LottoConstants.java
│           ├── controller
│           │   ├── LottoController.java
│           │   └── view
│           │       └── LottoView.java
│           ├── domain
│           │   ├── Lotto.java
│           │   ├── LottoCollection.java
│           │   └── LottoRank.java
│           ├── message
│           │   ├── ErrorMessage.java
│           │   ├── InputMessage.java
│           │   └── OutputMessage.java
│           ├── service
│           │   └── LottoService.java
│           └── validate
│               └── Validators.java
└── test
    └── java
        └── lotto
            ├── ApplicationTest.java
            ├── domain
            │   ├── LottoCollectionTest.java
            │   └── LottoTest.java
            ├── service
            │   └── LottoServiceTest.java
            └── validate
                └── ValidatorsTest.java
```
------------------------------------------------
# 구현 중 고민 했던 점, 막혔던 점, 새로 배운점

1. 열거형 클래스 (Enum)

문제 요구사항 중 enum을 사용하라는 항목이 있었습니다. 처음엔 어디에 써야 할지 명확하지 않았는데, 기능을 구현하다가 '로또 당첨 횟수 계산' 로직에서 막혔습니다.

이때 로또의 당첨 규칙(등수, 일치 개수, 상금)이야말로 enum으로 관리해야 할 데이터라는 것을 깨닫고, LottoRank라는 열거형 클래스를 만들었습니다.

2. 'domain' 패키지

Lotto 클래스를 어느 패키지에 두어야 할지 고민했습니다. entity보다는 domain이 옳다고 생각했습니다.

도메인(Domain): 애플리케이션의 비즈니스에 관련된 모든 개념 모델

엔티티(Entity): 도메인 내에서 식별 가능한 개별적인 객체 또는 개념

LottoRank 열거형처럼 비즈니스 규칙을 담는 객체들도 함께 위치해야 하므로, 더 포괄적인 domain 패키지를 선택했습니다.

3. 메세지 상수

메시지들을 상수로 관리하던 중, 요구사항(매직넘버, 메시지 상수화)을 보고 고민이 생겼습니다. '에러 메시지'와 '로또 번호 개수(6)' 같은 '게임 규칙 상수'를 같은 패키지에 둬야 할까요?

결론적으론 분리했습니다.

message 패키지: 사용자에게 보여줄 메시지 (책임: 출력)

config 패키지: 게임 규칙(숫자, 정규식) (책임: 설정) 둘 다 상수이지만, 책임이 완전히 다르다고 생각했습니다.

4. 테스트 코드

2주차 리뷰에서 배운 **@Nested**와 **@DisplayName**을 적극적으로 적용했습니다. DisplayName에 상황을 적고 메서드명은 테스트 대상 메서드명을 사용하니, 성공/실패 및 케이스별 테스트가 한눈에 들어와 가독성이 크게 향상되었습니다.

List, Map 등 컬렉션 값을 테스트에 주입해야 할 때는 **@MethodSource**를 사용해야 했는데, 검색을 통해 올바른 해결책을 찾을 수 있어서 새로운 지식을 습득했습니다.

5. 일급 컬렉션 (First-Class Collection)

2주차에 Repository를 사용하면서도 이게 과연 적절한 이름과 역할인지 의구심이 있었습니다. 코드 리뷰와 다른 분들의 코드를 통해 '일급 컬렉션'을 알게 되었고, 주말에 리팩토링을 결심했습니다.

일급 컬렉션이란 **'컬렉션을 감싸는 객체가 그 컬렉션과 관련된 비즈니스 로직을 스스로 처리하게 하여 응집도를 높이는 것'**이었습니다.

기존 Service와 Util 클래스에 흩어져 있던 비즈니스 로직(결과 계산, 수익률 계산 등)을 LottoCollection이라는 일급 컬렉션 객체로 옮겼습니다. 이 과정에서 로직을 다시 짜보며 문법이나 구현 방법을 복기하는 유익한 시간을 보냈습니다.

6. 상태 없는 서비스 (Stateless Service)

일급 컬렉션을 적용한 뒤, Service를 단위 테스트하는 과정에서 문제가 발생했습니다. Service가 LottoCollection을 필드(상태)로 들고 있으니, 테스트 코드에서 Service 내부의 LottoCollection을 제어할 방법이 없었습니다. (랜덤 값이 아닌, 제가 지정한 로또 목록으로 테스트하고 싶었습니다.)

Mockito 사용이 금지되었기에 가짜 객체를 주입할 수도 없었습니다.

임시방편으로 Service에 setter 메서드를 만들어 데이터를 주입했지만, 이는 '테스트를 위한 생산 코드 변경'이라 찝찝했습니다.

고민 끝에 참고한 블로그 글을 보고, Service를 '상태가 없게(Stateless)' 만들면 문제가 해결된다는 것을 깨달았습니다.

Controller가 LottoCollection을 생성하여 소유하고, Service의 메서드를 호출할 때마다 이 LottoCollection을 파라미터로 주입해주는 방식입니다.

이렇게 리팩토링하고 나니, 우테코에서 왜 Mockito를 사용하지 못하게 했는지 그 의도를 어렴풋이 이해할 수 있었습니다. '테스트하기 쉬운 코드'가 '좋은 코드'라는 것을 스스로 깨닫게 유도한 것이라 생각합니다.

7. 인터페이스

필요 없어 보이는 것들을 모두 삭제했더니, 이번 미션에서는 인터페이스가 하나도 남지 않았습니다. 확장성보다는 '테스트 코드 작성에 필요한가'만 따졌던 것 같습니다. 인터페이스를 언제, 얼마나 사용해야 하는지는 아직 명확한 기준이 서지 않아 더 고민해 봐야겠습니다.


